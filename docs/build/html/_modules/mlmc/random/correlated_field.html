

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>mlmc.random.correlated_field &mdash; mlmc 1.0.0 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../contents.html" class="icon icon-home"> mlmc
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../index.html">MLMC</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../index.html#installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../examples_sampler_creation.html">Sampler creation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples_samples_scheduling.html">Samples scheduling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_samples_scheduling.html#prescribe-the-exact-number-of-samples">1. Prescribe the exact number of samples</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_samples_scheduling.html#prescribe-a-target-variance">2. Prescribe a target variance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples_quantity.html">Quantity tutorial</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#mean-estimates">Mean estimates</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#estimate-moments-and-covariance-matrix">Estimate moments and covariance matrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#quantity-selection">Quantity selection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#binary-operations">Binary operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#numpy-universal-functions">NumPy universal functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_quantity.html#quantity-selection-by-conditions">Quantity selection by conditions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../examples_postprocessing.html">Results postprocessing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../examples_postprocessing.html#probability-density-function-approximation">Probability density function approximation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../mlmc.html">MLMC package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../mlmc.html#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../mlmc.html#classes">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#sampler">Sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#samplingpool">SamplingPool</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#samplingpoolpbs">SamplingPoolPBS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#samplestorage">SampleStorage</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#samplestoragehdf">SampleStorageHDF</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#estimate">Estimate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#moments">Moments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../mlmc.html#levelsimulation">LevelSimulation</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../contents.html">mlmc</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../contents.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>mlmc.random.correlated_field</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mlmc.random.correlated_field</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">numpy.random</span> <span class="k">as</span> <span class="nn">rand</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">sklearn.utils.extmath</span> <span class="kn">import</span> <span class="n">randomized_svd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;always&#39;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">gstools</span>


<div class="viewcode-block" id="kozeny_carman"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.kozeny_carman">[docs]</a><span class="k">def</span> <span class="nf">kozeny_carman</span><span class="p">(</span><span class="n">porosity</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">viscosity</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Kozeny-Carman law. Empirical relationship between porosity and conductivity.</span>
<span class="sd">    :param porosity: Porosity value.</span>
<span class="sd">    :param m: Power. Suitable values are 1 &lt; m &lt; 4</span>
<span class="sd">    :param factor: [m^2]</span>
<span class="sd">        E.g. 1e-7 ,   m = 3.48;  juta fibers</span>
<span class="sd">             2.2e-8 ,     1.46;  glass fibers</span>
<span class="sd">             1.8e-13,     2.89;  erruptive material</span>
<span class="sd">             1e-12        2.76;  erruptive material</span>
<span class="sd">             1.8e-12      1.99;  basalt</span>
<span class="sd">    :param viscosity: [Pa . s], water: 8.90e-4</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">viscosity</span> <span class="o">&gt;</span> <span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">porosity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">porosity</span><span class="p">,</span> <span class="mi">1</span><span class="o">-</span><span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">porosity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">porosity</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">factor</span> <span class="o">*</span> <span class="n">porosity</span> <span class="o">**</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">porosity</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">viscosity</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="mf">1e-15</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cond</span></div>


<div class="viewcode-block" id="positive_to_range"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.positive_to_range">[docs]</a><span class="k">def</span> <span class="nf">positive_to_range</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mapping a positive parameter &#39;exp&#39; from the interval &lt;0, \infty) to the interval &lt;a,b).</span>
<span class="sd">    Suitable e.g. to generate meaningful porosity from a variable with lognormal distribution.</span>
<span class="sd">    :param exp: A positive parameter. (LogNormal distribution.)</span>
<span class="sd">    :param a, b: Range interval.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">exp</span><span class="p">))</span></div>


<div class="viewcode-block" id="Field"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Field">[docs]</a><span class="k">class</span> <span class="nc">Field</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">param_fields</span><span class="o">=</span><span class="p">[],</span> <span class="n">regions</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param name: Name of the field.</span>
<span class="sd">        :param field: scalar (const field), or instance of SpatialCorrelatedField, or a callable</span>
<span class="sd">               for evaluation of the field from its param_fields.</span>
<span class="sd">        :param regions: Domain where field is sampled.</span>
<span class="sd">        :param param_fields: List of names of parameter fields, dependees.</span>
<span class="sd">        TODO: consider three different derived classes for: const, random and func fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">field</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_outer</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">regions</span> <span class="o">=</span> <span class="p">[</span><span class="n">regions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">RandomFieldBase</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span> <span class="o">=</span> <span class="n">field</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">param_fields</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">field</span>

            <span class="c1"># check callable</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">param_fields</span><span class="p">))]</span>
                <span class="n">field</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid field function for field: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">field</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">regions</span> <span class="o">=</span> <span class="n">regions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">param_fields</span> <span class="o">=</span> <span class="n">param_fields</span>

<div class="viewcode-block" id="Field.set_points"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Field.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to set evaluation points. See Fields.set_points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span><span class="o">.</span><span class="n">set_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span><span class="p">)</span> <span class="ow">is</span>  <span class="n">SpatialCorrelatedField</span><span class="p">:</span>
                <span class="c1"># TODO: make n_terms_range an optianal parmater for SpatialCorrelatedField</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span><span class="o">.</span><span class="n">svd_dcmp</span><span class="p">(</span><span class="n">n_terms_range</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span></div>

<div class="viewcode-block" id="Field.sample"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Field.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Internal method to generate/compute new sample.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlated_field</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[</span> <span class="n">pf</span><span class="o">.</span><span class="n">_sample</span> <span class="k">for</span> <span class="n">pf</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_fields</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span></div></div>


<div class="viewcode-block" id="Fields"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Fields">[docs]</a><span class="k">class</span> <span class="nc">Fields</span><span class="p">:</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fields</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new set of cross dependent random fields.</span>
<span class="sd">        Currently no support for cross-correlated random fields.</span>
<span class="sd">        A set of independent basic random fields must exist</span>
<span class="sd">        other fields can be dependent in deterministic way.</span>

<span class="sd">        :param fields: A list of dependent fields.</span>

<span class="sd">        Example:</span>
<span class="sd">        rf = SpatialCorrelatedField(log=True)</span>
<span class="sd">        Fields([</span>
<span class="sd">            Field(&#39;por_top&#39;, rf, regions=&#39;ground_0&#39;),</span>
<span class="sd">            Field(&#39;porosity_top&#39;, positive_to_range, [&#39;por_top&#39;, 0.02, 0.1], regions=&#39;ground_0&#39;),</span>
<span class="sd">            Field(&#39;por_bot&#39;, rf, regions=&#39;ground_1&#39;),</span>
<span class="sd">            Field(&#39;porosity_bot&#39;, positive_to_range, [&#39;por_bot&#39;, 0.01, 0.05], regions=&#39;ground_1&#39;),</span>
<span class="sd">            Field(&#39;conductivity_top&#39;, cf.kozeny_carman, [&#39;porosity_top&#39;, 1, 1e-8, water_viscosity], regions=&#39;ground_0&#39;),</span>
<span class="sd">            Field(&#39;conductivity_bot&#39;, cf.kozeny_carman, [&#39;porosity_bot&#39;, 1, 1e-10, water_viscosity],regions=&#39;ground_1&#39;)</span>
<span class="sd">            ])</span>

<span class="sd">        TODO: use topological sort to fix order of &#39;fields&#39;</span>
<span class="sd">        TODO: syntactic sugar for calculating with fields (like with np.arrays).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields_orig</span> <span class="o">=</span> <span class="n">fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Have to make a copy of the fields since we want to generate the samples in them</span>
        <span class="c1"># and the given instances of Field can be used by an independent FieldSet instance.</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_orig</span><span class="p">:</span>
            <span class="n">new_field</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new_field</span><span class="o">.</span><span class="n">param_fields</span><span class="p">:</span>
                <span class="n">new_field</span><span class="o">.</span><span class="n">param_fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_field_obj</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">new_field</span><span class="o">.</span><span class="n">regions</span><span class="p">)</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">new_field</span><span class="o">.</span><span class="n">param_fields</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">[</span><span class="n">new_field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_field</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_field</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_field_obj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">regions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get fields by name, replace constants by constant fields for unification.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
            <span class="n">const_field</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="s2">&quot;const_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_name</span><span class="p">),</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">regions</span><span class="o">=</span><span class="n">regions</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">const_field</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">[</span><span class="n">const_field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">const_field</span>
            <span class="k">return</span> <span class="n">const_field</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">,</span> <span class="s2">&quot;name: </span><span class="si">{}</span><span class="s2"> dict: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>

    <span class="c1"># def iterative_dfs(self, graph, start, path=[]):</span>
    <span class="c1">#     q = [start]</span>
    <span class="c1">#     while q:</span>
    <span class="c1">#         v = q.pop(0)</span>
    <span class="c1">#         if v not in path:</span>
    <span class="c1">#             path = path + [v]</span>
    <span class="c1">#             q = graph[v] + q</span>
    <span class="c1">#</span>
    <span class="c1">#     return path</span>

<div class="viewcode-block" id="Fields.set_outer_fields"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Fields.set_outer_fields">[docs]</a>    <span class="k">def</span> <span class="nf">set_outer_fields</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set fields that will be in a dictionary produced by FieldSet.sample() call.</span>
<span class="sd">        :param outer: A list of names of fields that are sampled.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">outer_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">outer</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">outer_set</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">is_outer</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">is_outer</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Fields.set_points"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Fields.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">region_ids</span><span class="o">=</span><span class="p">[],</span> <span class="n">region_map</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set mesh related data to fields.</span>
<span class="sd">        - set points for sample evaluation</span>
<span class="sd">        - translate region names to region ids in fields</span>
<span class="sd">        - create maps from region constraned point sets of fields to full point set</span>
<span class="sd">        :param points: np array of points for field evaluation</span>
<span class="sd">        :param regions: regions of the points;</span>
<span class="sd">               empty means no points for fields restricted to regions and all points for unrestricted fields</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">region_ids</span><span class="p">)</span>
        <span class="n">reg_points</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">region_ids</span><span class="p">):</span>
            <span class="n">reg_list</span> <span class="o">=</span> <span class="n">reg_points</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reg_id</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">reg_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">reg_points</span><span class="p">[</span><span class="n">reg_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg_list</span>

        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="n">point_ids</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">regions</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">reg</span> <span class="ow">in</span> <span class="n">field</span><span class="o">.</span><span class="n">regions</span><span class="p">:</span>
                    <span class="n">reg_id</span> <span class="o">=</span> <span class="n">region_map</span><span class="p">[</span><span class="n">reg</span><span class="p">]</span>
                    <span class="n">point_ids</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">reg_points</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reg_id</span><span class="p">,</span> <span class="p">[]))</span>
                <span class="n">field</span><span class="o">.</span><span class="n">set_points</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">point_ids</span><span class="p">])</span>
                <span class="n">field</span><span class="o">.</span><span class="n">full_sample_ids</span> <span class="o">=</span> <span class="n">point_ids</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">field</span><span class="o">.</span><span class="n">set_points</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
                <span class="n">field</span><span class="o">.</span><span class="n">full_sample_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fields.sample"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.Fields.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return dictionary of sampled fields.</span>
<span class="sd">        :return: { &#39;field_name&#39;: sample, ...}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">is_outer</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_elements</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="n">field</span><span class="o">.</span><span class="n">full_sample_ids</span><span class="p">]</span> <span class="o">=</span> <span class="n">sample</span>
        <span class="k">return</span> <span class="n">result</span></div></div>


<div class="viewcode-block" id="RandomFieldBase"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.RandomFieldBase">[docs]</a><span class="k">class</span> <span class="nc">RandomFieldBase</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for various methods for generating random fields.</span>

<span class="sd">    Generating realizations of a spatially correlated random field F for a fixed set of points at X.</span>
<span class="sd">    E[F(x)]       = mu(x)</span>
<span class="sd">    Cov_ij = Cov[x_i,x_j]  = E[(F(x_i) - mu(x))(F(x_j) - mu(x))]</span>

<span class="sd">    We assume stationary random field with covariance matrix Cov_ij:</span>
<span class="sd">        Cov_i,j = c(x_i - x_j)</span>
<span class="sd">    where c(X) is the &quot;stationary covariance&quot; function. We assume:</span>
<span class="sd">          c(X) = sigma^2 exp( -|X^t K X|^(alpha/2) )</span>
<span class="sd">    for spatially heterogeneous sigma(X) we consider particular non-stationary generalization:\</span>
<span class="sd">          Cov_i,i = sigma(x_i)*sigma(x_j) exp( -|X^t K X|^(alpha/2) ); X = x_i - x_j</span>

<span class="sd">    where:</span>
<span class="sd">        - sigma(X) is the standard deviance of the single uncorrelated value</span>
<span class="sd">        - K is a positive definite tensor with eigen vectors corresponding to</span>
<span class="sd">          main directions and eigen values equal to (1/l_i)^2, where l_i is correlation</span>
<span class="sd">          length in singel main direction.</span>
<span class="sd">        - alpha is =1 for &quot;exponential&quot; and =2 for &quot;Gauss&quot; correlation</span>

<span class="sd">    SVD decomposition:</span>
<span class="sd">        Considering first m vectors, such that lam(m)/lam(0) &lt;0.1</span>

<span class="sd">    Example:</span>
<span class="sd">    ```</span>
<span class="sd">        field = SpatialCorrelatedField(corr_exp=&#39;exp&#39;, corr_length=1.5)</span>
<span class="sd">        X, Y = np.mgrid[0:1:10j, 0:1:10j]</span>
<span class="sd">        points = np.vstack([X.ravel(), Y.ravel()])</span>
<span class="sd">        field.set_points(points)</span>
<span class="sd">        sample = field.sample()</span>

<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corr_exp</span><span class="o">=</span><span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">corr_length</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                 <span class="n">aniso_correlation</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param corr_exp: &#39;gauss&#39;, &#39;exp&#39; or a float (should be &gt;= 1)</span>
<span class="sd">        :param dim: dimension of the domain (size of point coords)</span>
<span class="sd">        :param corr_length: scalar, correlation length L &gt; machine epsilon; tensor K = (1/L)^2</span>
<span class="sd">        :param aniso_correlation: 3x3 array; K tensor, overrides correlation length</span>
<span class="sd">        :param mu - mu field (currently just a constant)</span>
<span class="sd">        :param sigma - sigma field (currently just a constant)</span>

<span class="sd">        TODO:</span>
<span class="sd">        - implement anisotropy in the base class using transformation matrix for the points</span>
<span class="sd">        - use transformation matrix also for the corr_length</span>
<span class="sd">        - replace corr_exp by aux classes for various correlation functions and pass them here</span>
<span class="sd">        - more general set of correlation functions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>

        <span class="k">if</span> <span class="n">corr_exp</span> <span class="o">==</span> <span class="s1">&#39;gauss&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="k">elif</span> <span class="n">corr_exp</span> <span class="o">==</span> <span class="s1">&#39;exp&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">corr_exp</span><span class="p">)</span>

        <span class="c1"># TODO: User should prescribe scaling for main axis and their rotation.</span>
        <span class="c1"># From this we should construct the transformation matrix for the points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_corr_length</span> <span class="o">=</span> <span class="n">corr_length</span>
        <span class="k">if</span> <span class="n">aniso_correlation</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">corr_length</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlation_tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">corr_length</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_corr_length</span> <span class="o">=</span> <span class="n">corr_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">correlation_tensor</span> <span class="o">=</span> <span class="n">aniso_correlation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_max_corr_length</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">aniso_correlation</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># largest eigen value</span>

        <span class="c1">#### Attributes set through `set_points`.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Evaluation points of the field.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="c1"># Mean in points. Or scalar.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="c1"># Standard deviance in points. Or scalar.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>  <span class="c1"># Implementation dependent initialization.</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<div class="viewcode-block" id="RandomFieldBase.set_points"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.RandomFieldBase.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param points: N x d array. Points X_i where the field will be evaluated. d is the dimension.</span>
<span class="sd">        :param mu: Scalar or N array. Mean value of uncorrelated field: E( F(X_i)).</span>
<span class="sd">        :param sigma: Scalar or N array. Standard deviance of uncorrelated field: sqrt( E ( F(X_i) - mu_i )^2 )</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>

        <span class="k">if</span> <span class="n">mu</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),)</span>

        <span class="k">if</span> <span class="n">sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">or</span> <span class="n">sigma</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">),)</span></div>

    <span class="k">def</span> <span class="nf">_set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<div class="viewcode-block" id="RandomFieldBase.sample"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.RandomFieldBase.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param uncorelated: Random samples from standard normal distribution.</span>
<span class="sd">               Removed as the spectral method do not support it.</span>
<span class="sd">        :return: Random field evaluated in points given by &#39;set_points&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if uncorelated is None:</span>
        <span class="c1">#     uncorelated = np.random.normal(0, 1, self.n_approx_terms)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     assert uncorelated.shape == (self.n_approx_terms,)</span>

        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample</span><span class="p">()</span>
        <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">field</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">field</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">field</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">uncorrelated</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>


<div class="viewcode-block" id="SpatialCorrelatedField"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.SpatialCorrelatedField">[docs]</a><span class="k">class</span> <span class="nc">SpatialCorrelatedField</span><span class="p">(</span><span class="n">RandomFieldBase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called after initialization in common constructor.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">### Attributes computed in precalculation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Covariance matrix (dense).</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n_approx_terms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Length of the sample vector, number of KL (Karhunen-Loe?ve) expansion terms.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># (Reduced) L factor of the SVD decomposition of the covariance matrix.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sqrt_ev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># (Reduced) square roots of singular values.</span>

    <span class="k">def</span> <span class="nf">_set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="SpatialCorrelatedField.cov_matrix"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.SpatialCorrelatedField.cov_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">cov_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Setup dense covariance matrix for given set of points.</span>
<span class="sd">        :return: None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;Points not set, call set_points.&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_points_bbox</span> <span class="o">=</span> <span class="n">box</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">diameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">box</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relative_corr_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_max_corr_length</span> <span class="o">/</span> <span class="n">diameter</span>

        <span class="c1"># sigma_sqr_mat = np.outer(self.sigma, self.sigma.T)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_sqr_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">n_pt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_pt</span><span class="p">,</span> <span class="n">n_pt</span><span class="p">))</span>
        <span class="n">corr_exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="k">for</span> <span class="n">i_row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pt</span><span class="p">):</span>
            <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">i_row</span><span class="p">]</span>
            <span class="n">diff_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">-</span> <span class="n">pt</span>
            <span class="n">len_sqr_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">diff_row</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">correlation_tensor</span><span class="p">)</span> <span class="o">*</span> <span class="n">diff_row</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">[</span><span class="n">i_row</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">len_sqr_row</span> <span class="o">**</span> <span class="n">corr_exp</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span></div>

    <span class="k">def</span> <span class="nf">_eigen_value_estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate of the m-th eigen value of the covariance matrix.</span>
<span class="sd">        According to paper: Schwab, Thodor: KL Approximation  of Random Fields by ...</span>
<span class="sd">        However for small gamma the asimtotics holds just for to big values of &#39;m&#39;.</span>
<span class="sd">        We rather need to find a semiempricial formula.</span>
<span class="sd">        greater</span>
<span class="sd">        :param m:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relative_corr_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sigma_sqr_max</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">gamma</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="n">m</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">sp</span><span class="o">.</span><span class="n">special</span><span class="o">.</span><span class="n">gamma</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">m</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">d</span><span class="p">))</span>

<div class="viewcode-block" id="SpatialCorrelatedField.svd_dcmp"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.SpatialCorrelatedField.svd_dcmp">[docs]</a>    <span class="k">def</span> <span class="nf">svd_dcmp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">n_terms_range</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does decomposition of covariance matrix defined by set of points</span>
<span class="sd">        :param precision: Desired accuracy of the KL approximation, smaller eigen values are dropped.</span>
<span class="sd">        :param n_terms_range: (min, max) number of terms in KL expansion to use. The number of terms estimated from</span>
<span class="sd">        given precision is snapped to the given interval.</span>

<span class="sd">        truncated SVD:</span>
<span class="sd">         cov_mat = U*diag(ev) * V,</span>
<span class="sd">         _cov_l_factor = U[:,0:m]*sqrt(ev[0:m])</span>

<span class="sd">        Note on number of terms:</span>
<span class="sd">        According to: C. Schwab and R. A. Todor: KL Approximation of Random Fields by Generalized Fast Multiploe Method</span>
<span class="sd">        the eigen values should decay as (Proposition 2.18):</span>
<span class="sd">            lambda_m ~ sigma^2 * ( 1/gamma ) **( m**(1/d) + alpha ) / Gamma(0.5 * m**(1/d) )</span>
<span class="sd">        where gamma = correlation length / domain diameter</span>
<span class="sd">        ans alpha is the correlation exponent. Gamma is the gamma function.</span>
<span class="sd">        ... should be checked experimantaly and generalized for sigma(X)</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cov_matrix</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">n_terms_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">:</span>
            <span class="n">U</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">n_terms_range</span><span class="p">)</span>
            <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_points</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">prec_range</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_eigen_value_estimate</span><span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigen_value_estimate</span><span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">precision</span> <span class="o">&lt;</span> <span class="n">prec_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">precision</span> <span class="o">&gt;</span> <span class="n">prec_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eigen_value_estimate</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">precision</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optmize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">)</span>

            <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">precision</span>
            <span class="c1"># TODO: Test if we should cut eigen values by relative (like now) or absolute value</span>
            <span class="k">while</span> <span class="n">threshold</span> <span class="o">&gt;=</span> <span class="n">precision</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&lt;=</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1">#print(&quot;treshold: {} m: {} precision: {} max_m: {}&quot;.format(threshold,  m, precision, range[1]))</span>
                <span class="n">U</span><span class="p">,</span> <span class="n">ev</span><span class="p">,</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">randomized_svd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">threshold</span> <span class="o">=</span> <span class="n">ev</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">m</span><span class="p">))</span>

            <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">#print(&quot;KL approximation: {} for {} points.&quot;.format(m, self.n_points))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_approx_terms</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sqrt_ev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sqrt_ev</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cov_mat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span><span class="p">,</span> <span class="n">ev</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">m</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param uncorelated: Random samples from standard normal distribution.</span>
<span class="sd">        :return: Random field evaluated in points given by &#39;set_points&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">svd_dcmp</span><span class="p">()</span>
        <span class="n">uncorelated</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_approx_terms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cov_l_factor</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">uncorelated</span><span class="p">)</span></div>


<div class="viewcode-block" id="GSToolsSpatialCorrelatedField"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.GSToolsSpatialCorrelatedField">[docs]</a><span class="k">class</span> <span class="nc">GSToolsSpatialCorrelatedField</span><span class="p">(</span><span class="n">RandomFieldBase</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param model: instance of covariance model class, which parent is gstools.covmodel.CovModel</span>
<span class="sd">        :param mode_no: number of Fourier modes, default: 1000 as in gstools package</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span> <span class="o">=</span> <span class="n">mode_no</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">srf</span> <span class="o">=</span> <span class="n">gstools</span><span class="o">.</span><span class="n">SRF</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="n">mode_no</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">srf</span><span class="o">.</span><span class="n">mean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>

<div class="viewcode-block" id="GSToolsSpatialCorrelatedField.change_srf"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.GSToolsSpatialCorrelatedField.change_srf">[docs]</a>    <span class="k">def</span> <span class="nf">change_srf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Spatial random field with new seed</span>
<span class="sd">        :param seed: int, random number generator seed</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">srf</span> <span class="o">=</span> <span class="n">gstools</span><span class="o">.</span><span class="n">SRF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">)</span></div>

<div class="viewcode-block" id="GSToolsSpatialCorrelatedField.random_field"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.GSToolsSpatialCorrelatedField.random_field">[docs]</a>    <span class="k">def</span> <span class="nf">random_field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate the spatial random field</span>
<span class="sd">        :return: field, np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
            <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">srf</span><span class="p">((</span><span class="n">x</span><span class="p">,))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">srf</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">srf</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">field</span></div>

<div class="viewcode-block" id="GSToolsSpatialCorrelatedField.sample"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.GSToolsSpatialCorrelatedField.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Random field evaluated in points given by &#39;set_points&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_field</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_field</span><span class="p">()</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="FourierSpatialCorrelatedField"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.FourierSpatialCorrelatedField">[docs]</a><span class="k">class</span> <span class="nc">FourierSpatialCorrelatedField</span><span class="p">(</span><span class="n">RandomFieldBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate spatial random fields</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Own intialization.</span>
<span class="sd">        :param mode_no: Number of Fourier modes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;FourierSpatialCorrelatedField class is deprecated, try to use GSToolsSpatialCorrelatedField class instead&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">len_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corr_length</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mode_no&quot;</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

<div class="viewcode-block" id="FourierSpatialCorrelatedField.get_normal_distr"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.FourierSpatialCorrelatedField.get_normal_distr">[docs]</a>    <span class="k">def</span> <span class="nf">get_normal_distr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normal distributed arrays</span>
<span class="sd">        :return: np.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">))</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">Z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Z</span></div>

    <span class="k">def</span> <span class="nf">_sample_sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_no</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uniform sampling on a d-dimensional sphere</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode_no : :class:`int`, optional</span>
<span class="sd">                number of the Fourier modes</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            coord : :class:`numpy.ndarray`</span>
<span class="sd">                x[, y[, z]] coordinates on the sphere with shape (dim, mode_no)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_k</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">ang1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">ang1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">ang1</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">mode_no</span><span class="p">)</span>
            <span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ang1</span><span class="p">)</span>
            <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ang1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For implementation see &quot;</span>
                                      <span class="s2">&quot;https://github.com/LSchueler/GSTools/blob/randomization_revisited/gstools/field/rng.py&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coord</span>

<div class="viewcode-block" id="FourierSpatialCorrelatedField.gau"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.FourierSpatialCorrelatedField.gau">[docs]</a>    <span class="k">def</span> <span class="nf">gau</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a gaussian spectrum</span>
<span class="sd">        :param mode_no: int, Number of Fourier modes</span>
<span class="sd">        :return: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">len_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_k</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">len_scale</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">mode_no</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_sphere</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">rad_u</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="c1"># weibull distribution sampling</span>
            <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">len_scale</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">rad_u</span><span class="p">))</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">coord</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For implementation see &quot;</span>
                                      <span class="s2">&quot;https://github.com/LSchueler/GSTools/blob/randomization_revisited/gstools/field/rng.py&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span></div>

<div class="viewcode-block" id="FourierSpatialCorrelatedField.exp"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.FourierSpatialCorrelatedField.exp">[docs]</a>    <span class="k">def</span> <span class="nf">exp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute an exponential spectrum</span>
<span class="sd">        :param mode_no: int, Number of Fourier modes</span>
<span class="sd">        :return: numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_empty_k</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">k_u</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">mode_no</span><span class="p">)</span>
            <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">k_u</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_scale</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">coord</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_sphere</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_random_stream</span><span class="p">()</span>
            <span class="n">rad_u</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">mode_no</span><span class="p">)</span>
            <span class="c1"># sampling with ppf</span>
            <span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">rad_u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">len_scale</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">coord</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;For implementation see &quot;</span>
                                      <span class="s2">&quot;https://github.com/LSchueler/GSTools/blob/randomization_revisited/gstools/field/rng.py&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">k</span></div>

    <span class="k">def</span> <span class="nf">_create_empty_k</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode_no</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create empty mode array with the correct shape.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            mode_no : :class:`int`</span>
<span class="sd">                number of the fourier modes</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            :class:`numpy.ndarray`</span>
<span class="sd">                the empty mode array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode_no</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="n">mode_no</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">_get_random_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">rand</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="mi">16</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>

<div class="viewcode-block" id="FourierSpatialCorrelatedField.random_field"><a class="viewcode-back" href="../../../mlmc.random.html#mlmc.random.correlated_field.FourierSpatialCorrelatedField.random_field">[docs]</a>    <span class="k">def</span> <span class="nf">random_field</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the random modes for the randomization method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span>
            <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">T</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">normal_distr_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_normal_distr</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlation_exponent</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">)</span>

        <span class="c1"># reshape for unstructured grid</span>
        <span class="k">for</span> <span class="n">dim_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">dim_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])</span>
            <span class="n">k</span><span class="p">[</span><span class="n">dim_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">dim_i</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">dim_i</span><span class="p">])))</span>

        <span class="n">summed_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        <span class="n">summed_modes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">summed_modes</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1"># Test to see if enough memory is available.</span>
        <span class="c1"># In case there isn&#39;t, divide Fourier modes into smaller chunks</span>
        <span class="n">chunk_no</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">chunk_no_exp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">chunk_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span> <span class="o">/</span> <span class="n">chunk_no</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">chunk_no</span><span class="p">):</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">chunk</span> <span class="o">*</span> <span class="n">chunk_len</span>
                    <span class="c1"># In case k[d,a:e] with e &gt;= len(k[d,:]) causes errors in</span>
                    <span class="c1"># numpy, use the commented min-function below</span>
                    <span class="c1"># e = min((chunk + 1) * chunk_len, self.mode_no-1)</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">chunk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_len</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">phase</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">x</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">phase</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">y</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span>
                                 <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">z</span><span class="p">)</span>

                    <span class="n">summed_modes</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normal_distr_values</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">phase</span><span class="p">)</span> <span class="o">+</span>
                               <span class="n">normal_distr_values</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span><span class="n">e</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">phase</span><span class="p">),</span>
                               <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">MemoryError</span><span class="p">:</span>
                <span class="n">chunk_no</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">**</span><span class="n">chunk_no_exp</span>
                <span class="n">chunk_no_exp</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Not enough memory. Dividing Fourier modes into </span><span class="si">{}</span><span class="s1"> &#39;</span>
                      <span class="s1">&#39;chunks.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chunk_no</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="n">field</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">mode_no</span><span class="p">)</span> <span class="o">*</span> <span class="n">summed_modes</span>
        <span class="k">return</span> <span class="n">field</span></div>

    <span class="k">def</span> <span class="nf">_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: Random field evaluated in points given by &#39;set_points&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_field</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">field</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">field</span><span class="p">)</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2022, Jan Březina, Martin Špetlík.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>