
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>src.mlmc.tool.distribution &#8212; mlmc daf documentation</title>
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
    <script src="../../../../_static/jquery.js"></script>
    <script src="../../../../_static/underscore.js"></script>
    <script src="../../../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for src.mlmc.tool.distribution</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">integrate</span>


<div class="viewcode-block" id="Distribution"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution">[docs]</a><span class="k">class</span> <span class="nc">Distribution</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of the distribution</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">moments_obj</span><span class="p">,</span> <span class="n">moment_data</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">force_decay</span><span class="o">=</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
                 <span class="n">monitor</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param moments_obj: Function for calculating moments</span>
<span class="sd">        :param moment_data: Array  of moments and their vars; (n_moments, 2)</span>
<span class="sd">        :param domain: Explicit domain fo reconstruction. None = use domain of moments.</span>
<span class="sd">        :param force_decay: Flag for each domain side to enforce decay of the PDF approximation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Family of moments basis functions.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments_basis</span> <span class="o">=</span> <span class="n">moments_obj</span>

        <span class="c1"># Moment evaluation function with bounded number of moments and their domain.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments_fn</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Domain of the density approximation (and moment functions).</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">moments_obj</span><span class="o">.</span><span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="c1"># Indicates whether force decay of PDF at domain endpoints.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decay_penalty</span> <span class="o">=</span> <span class="n">force_decay</span>

        <span class="c1"># Approximation of moment values.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_means</span> <span class="o">=</span> <span class="n">moment_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moment_errs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">moment_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Approximation paramters. Lagrange multipliers for moment equations.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Number of basis functions to approximate the density.</span>
        <span class="c1"># In future can be smaller then number of provided approximative moments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moment_means</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">moments_obj</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">moments_fn</span> <span class="o">=</span> <span class="n">moments_obj</span>

        <span class="c1"># Degree of Gauss quad to use on every subinterval determined by adaptive quad.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gauss_degree</span> <span class="o">=</span> <span class="mi">21</span>
        <span class="c1"># Panalty coef for endpoint derivatives</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_penalty_coef</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="c1"># Flag for monitoring convergence on stdout.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span> <span class="o">=</span> <span class="n">monitor</span>
    <span class="c1"># def choose_parameters_from_samples(self, samples):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Determine model hyperparameters, in particular domain of the density function,</span>
    <span class="c1">#     from given samples.</span>
    <span class="c1">#     :param samples: np array of samples from the distribution or its approximation.</span>
    <span class="c1">#     :return: None</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     self.domain = (np.min(samples), np.max(samples))</span>
    <span class="c1">#</span>
    <span class="c1"># @staticmethod</span>
    <span class="c1"># def choose_parameters_from_moments(mean, variance, quantile=0.9999, log=False):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     Determine model hyperparameters, in particular domain of the density function,</span>
    <span class="c1">#     from given samples.</span>
    <span class="c1">#     :param samples: np array of samples from the distribution or its approximation.</span>
    <span class="c1">#     :return: None</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if log:</span>
    <span class="c1">#         # approximate by log normal</span>
    <span class="c1">#         # compute mu, sigma parameters from observed mean and variance</span>
    <span class="c1">#         sigma_sq = np.log(np.exp(np.log(variance) - 2.0 * np.log(mean)) + 1.0)</span>
    <span class="c1">#         mu = np.log(mean) - sigma_sq / 2.0</span>
    <span class="c1">#         sigma = np.sqrt(sigma_sq)</span>
    <span class="c1">#         domain = tuple(sc.stats.lognorm.ppf([1.0 - quantile, quantile], s=sigma, scale=np.exp(mu)))</span>
    <span class="c1">#         assert np.isclose(mean, sc.stats.lognorm.mean(s=sigma, scale=np.exp(mu)))</span>
    <span class="c1">#         assert np.isclose(variance, sc.stats.lognorm.var(s=sigma, scale=np.exp(mu)))</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         domain = tuple(sc.stats.norm.ppf([1.0 - quantile, quantile], loc=mean, scale=np.sqrt(variance)))</span>
    <span class="c1">#     return domain</span>
    <span class="c1">#</span>
    <span class="c1"># def choose_parameters_from_approximation(self):</span>
    <span class="c1">#     pass</span>


<div class="viewcode-block" id="Distribution.estimate_density_minimize"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.estimate_density_minimize">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_density_minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">reg_param</span> <span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Optimize density estimation</span>
<span class="sd">        :param tol: Tolerance for the nonlinear system residual, after division by std errors for</span>
<span class="sd">        individual moment means, i.e.</span>
<span class="sd">        res = || (F_i - \mu_i) / \sigma_i ||_2</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize domain, multipliers, ...</span>

        <span class="c1"># Geometrical series for sizes with base 1.2.</span>
        <span class="c1"># Using just odd numbers.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reg_param</span> <span class="o">=</span> <span class="n">reg_param</span>
        <span class="n">base</span> <span class="o">=</span> <span class="mf">1.2</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">size</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">/=</span> <span class="n">base</span>
                <span class="n">odd_size</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">round</span><span class="p">((</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">odd_size</span> <span class="o">!=</span> <span class="n">sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">odd_size</span><span class="p">)</span>
            <span class="n">sizes</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
        <span class="c1">#print(&quot;sizes: &quot;, sizes)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">,</span> <span class="n">tol</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">)</span>
        <span class="n">init_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tolerances</span> <span class="o">=</span> <span class="p">[</span> <span class="n">tol</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">tol</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tol</span><span class="p">,</span> <span class="n">init_error</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sizes</span><span class="p">)</span> <span class="o">-</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">tolerances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">))</span>
        <span class="c1">#print(&quot;tolerances: &quot;, tolerances)</span>

        <span class="n">total_nit</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">approx_size</span><span class="p">,</span> <span class="n">approx_tol</span> <span class="ow">in</span>  <span class="nb">zip</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="n">tolerances</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span> <span class="o">=</span> <span class="n">approx_tol</span> <span class="o">/</span> <span class="mi">16</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_size</span><span class="p">(</span><span class="n">approx_size</span><span class="p">)</span>
            <span class="c1">#if approx_size == self.moments_fn.size or approx_size == sizes[0]:</span>
            <span class="c1">#    max_it = 200</span>
            <span class="c1">#else:</span>
            <span class="c1">#    max_it = 20</span>
            <span class="n">max_it</span> <span class="o">=</span> <span class="mi">200</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;trust-exact&#39;</span>
            <span class="c1">#method =&#39;Newton-CG&#39;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_functional</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                          <span class="n">jac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_gradient</span><span class="p">,</span>
                                          <span class="n">hess</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_jacobian_matrix</span><span class="p">,</span>
                                          <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;tol&#39;</span><span class="p">:</span> <span class="n">approx_tol</span><span class="p">,</span> <span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="n">approx_tol</span><span class="p">,</span>
                                                   <span class="s1">&#39;gtol&#39;</span><span class="p">:</span> <span class="n">approx_tol</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="n">max_it</span><span class="p">})</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
            <span class="n">jac_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">jac</span><span class="p">)</span>
            <span class="n">total_nit</span> <span class="o">+=</span> <span class="n">result</span><span class="o">.</span><span class="n">nit</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monitor</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration: size: </span><span class="si">{}</span><span class="s2"> nits: </span><span class="si">{}</span><span class="s2"> tol: </span><span class="si">{:5.3g}</span><span class="s2"> res: </span><span class="si">{:5.3g}</span><span class="s2"> msg: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">nit</span><span class="p">,</span> <span class="n">approx_tol</span><span class="p">,</span> <span class="n">jac_norm</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">message</span><span class="p">))</span>

        <span class="c1"># Fix normalization</span>
        <span class="n">gradient</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_exact_moment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">/=</span> <span class="n">gradient</span>

        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="ow">or</span> <span class="n">jac_norm</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">result</span><span class="o">.</span><span class="n">nit</span> <span class="o">=</span> <span class="n">total_nit</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fun_norm</span> <span class="o">=</span> <span class="n">jac_norm</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Distribution.estimate_density"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.estimate_density">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Run nonlinear iterative solver to estimate density, use previous solution as initial guess.</span>
<span class="sd">        Faster, but worse stability.</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize domain, multipliers, ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_params</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">root</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_gradient</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">,</span>
            <span class="n">jac</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_calculate_jacobian_matrix</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span>
        <span class="p">)</span>

        <span class="n">fun_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="ow">or</span> <span class="n">fun_norm</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fun_norm</span> <span class="o">=</span> <span class="n">fun_norm</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="Distribution.density"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.density">[docs]</a>    <span class="k">def</span> <span class="nf">density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">moments_fn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param value: float or np.array</span>
<span class="sd">        :param moments_fn: counting moments function</span>
<span class="sd">        :return: density for passed value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span>
        <span class="k">if</span> <span class="n">moments_fn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">moments_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments_fn</span>
        <span class="n">moments</span> <span class="o">=</span> <span class="n">moments_fn</span><span class="o">.</span><span class="n">eval_all</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">moments</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="Distribution.cdf"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.cdf">[docs]</a>    <span class="k">def</span> <span class="nf">cdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">last_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">last_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cdf_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">val</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">last_y</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">val</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">last_y</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">fixed_quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">density</span><span class="p">,</span> <span class="n">last_x</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">last_x</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">last_y</span> <span class="o">=</span> <span class="n">last_y</span> <span class="o">+</span> <span class="n">dy</span>
            <span class="n">cdf_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">last_y</span>
        <span class="k">return</span> <span class="n">cdf_y</span></div>


    <span class="k">def</span> <span class="nf">_initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize parameters for density estimation</span>
<span class="sd">        :return: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">assert</span> <span class="n">tol</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">/</span> <span class="mi">16</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">moment_errs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">moment_errs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">8</span>
        <span class="c1"># Start with uniform distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_errs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Log to store error messages from quad, report only on conv. problem.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_log</span> <span class="o">=</span> <span class="p">[]</span>


<div class="viewcode-block" id="Distribution.extend_size"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.extend_size">[docs]</a>    <span class="k">def</span> <span class="nf">extend_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_solved_multipliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_stab_penalty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reg_param</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">)</span>
        <span class="c1">#self._stab_penalty = 0.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span> <span class="o">=</span> <span class="n">new_size</span>
        <span class="n">multipliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)]</span> <span class="o">=</span> <span class="n">multipliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_means</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_means</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">moment_errs</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">]</span>


        <span class="c1"># Evaluate endpoint derivatives of the moments.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_point_derivatives</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_quadrature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>
        <span class="c1">#self._calculate_gradient(self.multipliers)</span>

<div class="viewcode-block" id="Distribution.eval_moments"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.eval_moments">[docs]</a>    <span class="k">def</span> <span class="nf">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">moments_fn</span><span class="o">.</span><span class="n">eval_all</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_calculate_exact_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">moms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">moms</span> <span class="o">*</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">moms</span><span class="p">[:,</span><span class="n">m</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">epsabs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="n">full_output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_calculate_exact_hessian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">multipliers</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">multipliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">multipliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multipliers</span>

        <span class="k">def</span> <span class="nf">integrand</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">moms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">moms</span> <span class="o">*</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span> <span class="o">*</span> <span class="n">moms</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">moms</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                   <span class="n">epsabs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">_update_quadrature</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update quadrature points and their moments and weights based on integration of the density.</span>
<span class="sd">        return: True if update of gradient is necessary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">force</span><span class="p">:</span>
            <span class="n">mult_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">multipliers</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_multipliers</span><span class="p">)</span>
            <span class="n">grad_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_gradient</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">grad_norm</span> <span class="o">*</span> <span class="n">mult_norm</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span><span class="p">:</span>
                <span class="c1">#print(&quot;OPT&quot;)</span>
                <span class="k">return</span>

            <span class="c1">#print(grad_norm * mult_norm, self._quad_tolerance)</span>
            <span class="c1"># More precise but depends on actual gradient which may not be available</span>
            <span class="n">quad_err_estimate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_gradient</span><span class="p">,</span> <span class="p">(</span><span class="n">multipliers</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_multipliers</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">quad_err_estimate</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_tolerance</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">val</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_exact_moment</span><span class="p">(</span><span class="n">multipliers</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">abserr</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">message</span> <span class="o">=</span> <span class="n">result</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_quad_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y</span><span class="p">,</span> <span class="n">abserr</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">message</span> <span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="n">pt</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">legendre</span><span class="o">.</span><span class="n">leggauss</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_gauss_degree</span><span class="p">)</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]</span>
        <span class="c1">#print(&quot;Update Quad: {} {} {} {}&quot;.format(K, y, abserr, message))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;alist&#39;</span><span class="p">][:</span><span class="n">K</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;blist&#39;</span><span class="p">][:</span><span class="n">K</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="n">a</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_points</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_weights</span> <span class="o">=</span> <span class="n">weights</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_points</span><span class="p">)</span>

        <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">,</span> <span class="n">multipliers</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>
        <span class="n">q_gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_gradient</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_weights</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_multipliers</span> <span class="o">=</span> <span class="n">multipliers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_last_gradient</span> <span class="o">=</span> <span class="n">integral</span>

<div class="viewcode-block" id="Distribution.end_point_derivatives"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.Distribution.end_point_derivatives">[docs]</a>    <span class="k">def</span> <span class="nf">end_point_derivatives</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute approximation of moment derivatives at endpoints of the domain.</span>
<span class="sd">        :return: array (2, n_moments)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-10</span>
        <span class="n">left_diff</span> <span class="o">=</span> <span class="n">right_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_penalty</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">left_diff</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">decay_penalty</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">right_diff</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_moments</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">left_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">right_diff</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">eps</span><span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>


    <span class="k">def</span> <span class="nf">_calculate_functional</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Minimized functional.</span>
<span class="sd">        :param multipliers: current multipliers</span>
<span class="sd">        :return: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">update_grad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_update_quadrature</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)</span>

        <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">,</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>
        <span class="n">q_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_density</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_weights</span><span class="p">)</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_moment_means</span> <span class="o">*</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span>

        <span class="n">end_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">)</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">end_diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span>  <span class="nb">sum</span> <span class="o">+</span> <span class="n">integral</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">fun</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_penalty_coef</span> <span class="o">*</span> <span class="n">penalty</span>
        <span class="n">last_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_solved_multipliers</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stab_penalty</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_solved_multipliers</span> <span class="o">-</span> <span class="n">multipliers</span><span class="p">[:</span><span class="n">last_size</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fun</span>


    <span class="k">def</span> <span class="nf">_calculate_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gradient of th functional</span>
<span class="sd">        :return: array, shape (n_moments,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_quadrature</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">,</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span>
        <span class="c1">#power = np.minimum(np.maximum(power, -200), 200)</span>
        <span class="n">q_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="n">q_gradient</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">q_density</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_gradient</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_weights</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span>

        <span class="n">end_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">)</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">end_diff</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_moment_means</span> <span class="o">*</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span> <span class="o">+</span> <span class="n">integral</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">gradient</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">_moment_means</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span> <span class="o">-</span> <span class="n">integral</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_penalty_coef</span> <span class="o">*</span> <span class="n">penalty</span>
        <span class="n">last_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_last_solved_multipliers</span><span class="p">)</span>
        <span class="n">gradient</span><span class="p">[:</span><span class="n">last_size</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stab_penalty</span> <span class="o">*</span> <span class="p">(</span><span class="n">multipliers</span><span class="p">[:</span><span class="n">last_size</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_last_solved_multipliers</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gradient</span>

    <span class="k">def</span> <span class="nf">_calculate_jacobian_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: jacobian matrix, symmetric, (n_moments, n_moments)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_quadrature</span><span class="p">(</span><span class="n">multipliers</span><span class="p">)</span>

        <span class="n">power</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">,</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">power</span><span class="p">,</span> <span class="o">-</span><span class="mi">200</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>
        <span class="n">q_density</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">power</span><span class="p">)</span>
        <span class="n">moment_outer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ki,kj-&gt;ijk&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_moments</span><span class="p">)</span>
        <span class="n">triu_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">)</span>
        <span class="n">triu_outer</span> <span class="o">=</span> <span class="n">moment_outer</span><span class="p">[</span><span class="n">triu_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">triu_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
        <span class="n">q_jac</span> <span class="o">=</span> <span class="n">triu_outer</span> <span class="o">*</span> <span class="n">q_density</span>
        <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">q_jac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_quad_weights</span><span class="p">)</span>
        <span class="n">integral</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">[</span><span class="n">triu_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">integral</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">[</span><span class="n">triu_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">jacobian_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">approx_size</span><span class="p">))</span>
        <span class="n">jacobian_matrix</span><span class="p">[</span><span class="n">triu_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">triu_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">integral</span>
        <span class="n">jacobian_matrix</span><span class="p">[</span><span class="n">triu_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">triu_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">integral</span>

        <span class="n">end_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">,</span> <span class="n">multipliers</span><span class="p">)</span>
        <span class="n">fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_moment_means</span> <span class="o">*</span> <span class="n">multipliers</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">)</span> \
              <span class="o">+</span> <span class="n">jacobian_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_moment_errs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">end_diff</span><span class="p">[</span><span class="n">side</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">penalty</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">[</span><span class="n">side</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_end_point_diff</span><span class="p">[</span><span class="n">side</span><span class="p">])</span>
                <span class="n">jacobian_matrix</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fun</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_penalty_coef</span> <span class="o">*</span> <span class="n">penalty</span>

        <span class="n">jacobian_matrix</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">(</span><span class="n">jacobian_matrix</span><span class="p">)]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stab_penalty</span>


        <span class="c1">#e_vals = np.linalg.eigvalsh(jacobian_matrix)</span>

        <span class="c1">#print(multipliers)</span>
        <span class="c1">#print(&quot;jac spectra: &quot;, e_vals[0], e_vals[-1], e_vals[-1]/e_vals[0])</span>
        <span class="k">return</span> <span class="n">jacobian_matrix</span></div>



<div class="viewcode-block" id="compute_exact_moments"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.compute_exact_moments">[docs]</a><span class="k">def</span> <span class="nf">compute_exact_moments</span><span class="p">(</span><span class="n">moments_fn</span><span class="p">,</span> <span class="n">density</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute approximation of moments using exact density.</span>
<span class="sd">    :param moments_fn: Moments function.</span>
<span class="sd">    :param n_moments: Number of mements to compute.</span>
<span class="sd">    :param density: Density function (must accept np vectors).</span>
<span class="sd">    :param a, b: Integral bounds, approximate integration over R.</span>
<span class="sd">    :param tol: Tolerance of integration.</span>
<span class="sd">    :return: np.array, moment values</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">moments_fn</span><span class="o">.</span><span class="n">domain</span>
    <span class="n">integral</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">moments_fn</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">moments_fn</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="n">i</span><span class="p">:</span> <span class="n">moments_fn</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">density</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">integral</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">epsabs</span> <span class="o">=</span> <span class="n">tol</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">integral</span></div>


<div class="viewcode-block" id="KL_divergence"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.KL_divergence">[docs]</a><span class="k">def</span> <span class="nf">KL_divergence</span><span class="p">(</span><span class="n">prior_density</span><span class="p">,</span> <span class="n">posterior_density</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute D_KL(P | Q) = \int_R P(x) \log( P(X)/Q(x)) \dx</span>
<span class="sd">    :param prior_density: P</span>
<span class="sd">    :param posterior_density: Q</span>
<span class="sd">    :return: KL divergence value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">prior_density</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">prior_density</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">posterior_density</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="o">-</span><span class="mf">1e300</span><span class="p">)</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">epsabs</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="mf">1e-10</span><span class="p">)</span></div>


<div class="viewcode-block" id="L2_distance"><a class="viewcode-back" href="../../../../src.mlmc.tool.html#src.mlmc.tool.distribution.L2_distance">[docs]</a><span class="k">def</span> <span class="nf">L2_distance</span><span class="p">(</span><span class="n">prior_density</span><span class="p">,</span> <span class="n">posterior_density</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">posterior_density</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">prior_density</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">integrand</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">mlmc</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../src.mlmc.quantity.html">src.mlmc.quantity package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../src.mlmc.html">src.mlmc package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  <li><a href="../../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, asdf.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>